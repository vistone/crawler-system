# 多协议支持策略 - HTTP/1.1、HTTP/2、HTTP/3

## 协议特性分析

### HTTP/1.1
- **特点**：成熟稳定，广泛支持
- **连接方式**：TCP连接
- **复用**：Keep-Alive支持连接复用
- **适用场景**：通用场景，兼容性最好

### HTTP/2
- **特点**：多路复用，头部压缩
- **连接方式**：基于TLS的TCP连接（h2）或明文TCP（h2c）
- **复用**：单连接多路复用，效率高
- **适用场景**：需要高并发、减少连接数

### HTTP/3
- **特点**：基于QUIC，0-RTT，更好的拥塞控制
- **连接方式**：QUIC协议（UDP）
- **复用**：QUIC多路复用
- **适用场景**：高延迟网络、移动网络、需要快速建立连接

## 核心策略设计

### 1. IP库管理策略

#### 1.1 IP库结构设计

```go
// IP库存储结构
type IPLibrary struct {
    // 域名 -> IP列表映射
    DomainIPs map[string][]*DomainIPRecord
    
    // IP -> 域名列表映射（反向索引）
    IPDomains map[string][]string
    
    // IP健康状态
    IPHealth map[string]*IPHealthStatus
    
    // DNS解析记录
    DNSRecords map[string]*DNSRecord
}

// DomainIPRecord 域名IP记录
type DomainIPRecord struct {
    IP          string
    Port        int
    Protocol    string        // http1.1, http2, http3
    IsHealthy   bool
    LastChecked time.Time
    SuccessRate float64       // 成功率
    Latency     time.Duration // 平均延迟
    UseCount    int64         // 使用次数
    LastUsed    time.Time
    TTL         time.Duration // DNS TTL
    ExpiresAt   time.Time     // 过期时间
}

// IPHealthStatus IP健康状态
type IPHealthStatus struct {
    IP            string
    IsHealthy     bool
    IsBlocked     bool
    LastChecked   time.Time
    CheckInterval time.Duration
    ErrorCount    int
    SuccessCount  int
    Protocols     map[string]bool // 支持的协议
}
```

#### 1.2 IP库更新策略

```go
// IP库更新策略
type IPLibraryStrategy struct {
    // 更新触发条件
    UpdateTriggers []UpdateTrigger
    
    // 更新频率
    UpdateInterval time.Duration
    
    // IP过期策略
    ExpirationStrategy ExpirationStrategy
    
    // 健康检查策略
    HealthCheckStrategy HealthCheckStrategy
}

// UpdateTrigger 更新触发条件
type UpdateTrigger string

const (
    TriggerTimeBased    UpdateTrigger = "time_based"     // 定时更新
    TriggerFailureBased UpdateTrigger = "failure_based"  // 失败触发
    TriggerUsageBased   UpdateTrigger = "usage_based"    // 使用频率触发
    TriggerManual       UpdateTrigger = "manual"         // 手动触发
)

// ExpirationStrategy IP过期策略
type ExpirationStrategy struct {
    // 基于TTL过期
    UseTTL bool
    
    // 固定过期时间
    FixedExpiration time.Duration
    
    // 动态过期（根据使用情况）
    DynamicExpiration bool
}
```

### 2. 协议选择策略

#### 2.1 协议优先级

```go
// ProtocolPriority 协议优先级配置
type ProtocolPriority struct {
    // 默认协议优先级
    DefaultPriority []string // ["http3", "http2", "http1.1"]
    
    // 域名特定优先级
    DomainPriority map[string][]string
    
    // IP特定优先级
    IPPriority map[string][]string
    
    // 协议降级策略
    FallbackStrategy FallbackStrategy
}

// FallbackStrategy 降级策略
type FallbackStrategy struct {
    // 失败后降级
    OnFailure bool
    
    // 超时后降级
    OnTimeout bool
    
    // 错误类型降级
    OnErrorType map[string]bool
    
    // 降级顺序
    FallbackOrder []string
}
```

#### 2.2 协议检测策略

```go
// ProtocolDetection 协议检测
type ProtocolDetection struct {
    // 自动检测支持的协议
    AutoDetect bool
    
    // 检测方法
    DetectionMethods []DetectionMethod
    
    // 检测缓存
    DetectionCache map[string][]string
}

// DetectionMethod 检测方法
type DetectionMethod string

const (
    MethodALPN        DetectionMethod = "alpn"         // ALPN协商
    MethodHTTP2       DetectionMethod = "http2"        // HTTP/2检测
    MethodHTTP3       DetectionMethod = "http3"        // HTTP/3检测
    MethodTrialRequest DetectionMethod = "trial_request" // 试探请求
)
```

### 3. 连接管理策略

#### 3.1 多协议连接池

```go
// MultiProtocolConnectionPool 多协议连接池
type MultiProtocolConnectionPool struct {
    // HTTP/1.1连接池
    HTTP11Pool *netconnpool.Pool
    
    // HTTP/2连接池
    HTTP2Pool *http2pool.Pool
    
    // HTTP/3连接池
    HTTP3Pool *quic.Pool
    
    // 协议选择器
    ProtocolSelector *ProtocolSelector
    
    // IP库
    IPLibrary *IPLibrary
}

// ProtocolSelector 协议选择器
type ProtocolSelector struct {
    // 优先级配置
    Priority *ProtocolPriority
    
    // 协议检测器
    Detector *ProtocolDetection
    
    // 选择策略
    Strategy SelectionStrategy
}

// SelectionStrategy 选择策略
type SelectionStrategy string

const (
    StrategyPriority     SelectionStrategy = "priority"      // 优先级策略
    StrategyRoundRobin  SelectionStrategy = "round_robin"    // 轮询策略
    StrategyPerformance SelectionStrategy = "performance"    // 性能策略
    StrategyAdaptive     SelectionStrategy = "adaptive"      // 自适应策略
)
```

### 4. 请求路由策略

#### 4.1 IP优先策略

```go
// RequestRouting 请求路由
type RequestRouting struct {
    // 路由策略
    Strategy RoutingStrategy
    
    // IP库
    IPLibrary *IPLibrary
    
    // 降级策略
    Fallback *FallbackStrategy
}

// RoutingStrategy 路由策略
type RoutingStrategy string

const (
    // IP优先：优先使用IP库中的IP
    StrategyIPFirst RoutingStrategy = "ip_first"
    
    // 域名优先：优先使用域名
    StrategyDomainFirst RoutingStrategy = "domain_first"
    
    // 智能选择：根据情况自动选择
    StrategySmart RoutingStrategy = "smart"
    
    // 混合模式：同时尝试IP和域名
    StrategyHybrid RoutingStrategy = "hybrid"
)
```

## 实现方案

### 1. IP库管理器

```go
package iplibrary

import (
    "context"
    "sync"
    "time"
)

// IPLibraryManager IP库管理器
type IPLibraryManager struct {
    library  *IPLibrary
    resolver *domaindns.Resolver
    logger   *logs.Logger
    mutex    sync.RWMutex
    
    // 配置
    config *IPLibraryConfig
}

// IPLibraryConfig IP库配置
type IPLibraryConfig struct {
    // 更新间隔
    UpdateInterval time.Duration
    
    // IP过期时间
    IPExpiration time.Duration
    
    // 健康检查间隔
    HealthCheckInterval time.Duration
    
    // 最大IP数量
    MaxIPsPerDomain int
    
    // 最小健康IP数量
    MinHealthyIPs int
}

// NewIPLibraryManager 创建IP库管理器
func NewIPLibraryManager(
    resolver *domaindns.Resolver,
    logger *logs.Logger,
    config *IPLibraryConfig,
) *IPLibraryManager {
    return &IPLibraryManager{
        library: &IPLibrary{
            DomainIPs:  make(map[string][]*DomainIPRecord),
            IPDomains:  make(map[string][]string),
            IPHealth:   make(map[string]*IPHealthStatus),
            DNSRecords: make(map[string]*DNSRecord),
        },
        resolver: resolver,
        logger:   logger,
        config:   config,
    }
}

// GetIPsForDomain 获取域名的IP列表
func (m *IPLibraryManager) GetIPsForDomain(
    ctx context.Context,
    domain string,
    protocol string,
) ([]*DomainIPRecord, error) {
    m.mutex.RLock()
    defer m.mutex.RUnlock()
    
    // 从缓存获取
    if records, ok := m.library.DomainIPs[domain]; ok {
        // 过滤健康且支持协议的IP
        healthyIPs := m.filterHealthyIPs(records, protocol)
        if len(healthyIPs) > 0 {
            return healthyIPs, nil
        }
    }
    
    // 缓存未命中，需要解析
    m.mutex.RUnlock()
    return m.resolveAndCache(ctx, domain, protocol)
}

// resolveAndCache 解析并缓存
func (m *IPLibraryManager) resolveAndCache(
    ctx context.Context,
    domain string,
    protocol string,
) ([]*DomainIPRecord, error) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    // 解析域名
    ips, err := m.resolver.Resolve(ctx, domain)
    if err != nil {
        return nil, err
    }
    
    // 创建IP记录
    records := make([]*DomainIPRecord, 0, len(ips))
    for _, ip := range ips {
        record := &DomainIPRecord{
            IP:          ip,
            Port:        443,
            Protocol:    protocol,
            IsHealthy:   true,
            LastChecked: time.Now(),
            SuccessRate: 1.0,
            TTL:         m.config.IPExpiration,
            ExpiresAt:   time.Now().Add(m.config.IPExpiration),
        }
        records = append(records, record)
        
        // 更新反向索引
        m.library.IPDomains[ip] = append(m.library.IPDomains[ip], domain)
    }
    
    // 缓存记录
    m.library.DomainIPs[domain] = records
    
    m.logger.Info("DNS解析并缓存", "domain", domain, "ip_count", len(records))
    
    return records, nil
}

// filterHealthyIPs 过滤健康的IP
func (m *IPLibraryManager) filterHealthyIPs(
    records []*DomainIPRecord,
    protocol string,
) []*DomainIPRecord {
    healthy := make([]*DomainIPRecord, 0)
    now := time.Now()
    
    for _, record := range records {
        // 检查是否过期
        if record.ExpiresAt.Before(now) {
            continue
        }
        
        // 检查健康状态
        if !record.IsHealthy {
            continue
        }
        
        // 检查协议支持
        if record.Protocol != "" && record.Protocol != protocol {
            continue
        }
        
        healthy = append(healthy, record)
    }
    
    return healthy
}

// MarkIPHealthy 标记IP为健康
func (m *IPLibraryManager) MarkIPHealthy(ip string) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    if status, ok := m.library.IPHealth[ip]; ok {
        status.IsHealthy = true
        status.IsBlocked = false
        status.ErrorCount = 0
        status.LastChecked = time.Now()
        status.SuccessCount++
    }
}

// MarkIPBlocked 标记IP为被封锁
func (m *IPLibraryManager) MarkIPBlocked(ip string) {
    m.mutex.Lock()
    defer m.library.IPHealth[ip]
    
    if status, ok := m.library.IPHealth[ip]; ok {
        status.IsBlocked = true
        status.IsHealthy = false
        status.ErrorCount++
        status.LastChecked = time.Now()
    }
    
    // 标记相关域名记录
    if domains, ok := m.library.IPDomains[ip]; ok {
        for _, domain := range domains {
            if records, ok := m.library.DomainIPs[domain]; ok {
                for _, record := range records {
                    if record.IP == ip {
                        record.IsHealthy = false
                    }
                }
            }
        }
    }
}

// StartHealthCheck 启动健康检查
func (m *IPLibraryManager) StartHealthCheck(ctx context.Context) {
    ticker := time.NewTicker(m.config.HealthCheckInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            m.performHealthCheck(ctx)
        }
    }
}

// performHealthCheck 执行健康检查
func (m *IPLibraryManager) performHealthCheck(ctx context.Context) {
    m.mutex.RLock()
    domains := make([]string, 0, len(m.library.DomainIPs))
    for domain := range m.library.DomainIPs {
        domains = append(domains, domain)
    }
    m.mutex.RUnlock()
    
    // 并发检查
    for _, domain := range domains {
        go m.checkDomainIPs(ctx, domain)
    }
}

// checkDomainIPs 检查域名的IP
func (m *IPLibraryManager) checkDomainIPs(ctx context.Context, domain string) {
    // 实现健康检查逻辑
    // 例如：发送HEAD请求检查IP是否可用
}
```

### 2. 多协议请求执行器

```go
package crawler

import (
    "context"
    "fmt"
    "time"
)

// MultiProtocolExecutor 多协议请求执行器
type MultiProtocolExecutor struct {
    ipLibrary    *iplibrary.IPLibraryManager
    protocolPool *MultiProtocolConnectionPool
    logger       *logs.Logger
    
    // 配置
    config *ExecutorConfig
}

// ExecutorConfig 执行器配置
type ExecutorConfig struct {
    // 协议优先级
    ProtocolPriority []string
    
    // 路由策略
    RoutingStrategy RoutingStrategy
    
    // 降级策略
    FallbackStrategy *FallbackStrategy
    
    // 超时配置
    Timeout time.Duration
    
    // 重试配置
    RetryConfig *RetryConfig
}

// Execute 执行请求
func (e *MultiProtocolExecutor) Execute(
    ctx context.Context,
    req *Request,
) (*Response, error) {
    // 1. 选择路由策略
    routing := e.selectRouting(req)
    
    // 2. 选择协议
    protocol := e.selectProtocol(req, routing)
    
    // 3. 获取IP或域名
    target, err := e.getTarget(ctx, req.URL, routing, protocol)
    if err != nil {
        return nil, err
    }
    
    // 4. 执行请求（带降级）
    return e.executeWithFallback(ctx, req, target, protocol)
}

// selectRouting 选择路由策略
func (e *MultiProtocolExecutor) selectRouting(req *Request) RoutingStrategy {
    // 根据配置和请求特征选择路由策略
    return e.config.RoutingStrategy
}

// selectProtocol 选择协议
func (e *MultiProtocolExecutor) selectProtocol(
    req *Request,
    routing RoutingStrategy,
) string {
    // 根据优先级和请求特征选择协议
    for _, proto := range e.config.ProtocolPriority {
        return proto
    }
    return "http1.1" // 默认
}

// getTarget 获取目标（IP或域名）
func (e *MultiProtocolExecutor) getTarget(
    ctx context.Context,
    url string,
    routing RoutingStrategy,
    protocol string,
) (*Target, error) {
    domain := extractDomain(url)
    
    switch routing {
    case StrategyIPFirst:
        // IP优先：从IP库获取IP
        ips, err := e.ipLibrary.GetIPsForDomain(ctx, domain, protocol)
        if err != nil || len(ips) == 0 {
            // IP库中没有，降级到域名
            e.logger.Warn("IP库中无记录，降级到域名", "domain", domain)
            return &Target{Type: "domain", Value: domain}, nil
        }
        
        // 选择最佳IP
        ip := e.selectBestIP(ips)
        return &Target{Type: "ip", Value: ip.IP, Port: ip.Port}, nil
        
    case StrategyDomainFirst:
        // 域名优先：直接使用域名
        return &Target{Type: "domain", Value: domain}, nil
        
    case StrategySmart:
        // 智能选择：优先IP，失败后降级
        ips, err := e.ipLibrary.GetIPsForDomain(ctx, domain, protocol)
        if err == nil && len(ips) > 0 {
            ip := e.selectBestIP(ips)
            return &Target{Type: "ip", Value: ip.IP, Port: ip.Port}, nil
        }
        return &Target{Type: "domain", Value: domain}, nil
        
    default:
        return &Target{Type: "domain", Value: domain}, nil
    }
}

// Target 目标
type Target struct {
    Type  string // "ip" or "domain"
    Value string
    Port  int
}

// executeWithFallback 执行请求（带降级）
func (e *MultiProtocolExecutor) executeWithFallback(
    ctx context.Context,
    req *Request,
    target *Target,
    protocol string,
) (*Response, error) {
    // 按协议优先级尝试
    protocols := e.getProtocolOrder(protocol)
    
    var lastErr error
    for _, proto := range protocols {
        resp, err := e.executeProtocol(ctx, req, target, proto)
        if err == nil {
            return resp, nil
        }
        
        lastErr = err
        
        // 检查是否需要降级
        if !e.shouldFallback(err) {
            break
        }
        
        e.logger.Warn("协议请求失败，尝试降级", 
            "protocol", proto,
            "error", err,
        )
    }
    
    return nil, fmt.Errorf("所有协议尝试失败: %w", lastErr)
}

// executeProtocol 执行特定协议的请求
func (e *MultiProtocolExecutor) executeProtocol(
    ctx context.Context,
    req *Request,
    target *Target,
    protocol string,
) (*Response, error) {
    // 获取连接
    conn, err := e.protocolPool.GetConnection(ctx, &ConnectionOptions{
        Target:    target,
        Protocol:  protocol,
        Fingerprint: req.Fingerprint,
    })
    if err != nil {
        return nil, err
    }
    defer e.protocolPool.PutConnection(conn)
    
    // 发送请求
    return conn.SendRequest(ctx, req)
}

// shouldFallback 判断是否应该降级
func (e *MultiProtocolExecutor) shouldFallback(err error) bool {
    if e.config.FallbackStrategy == nil {
        return false
    }
    
    // 根据错误类型判断
    // 例如：连接错误、超时错误可以降级
    // 认证错误、404错误不应该降级
    return true
}

// selectBestIP 选择最佳IP
func (e *MultiProtocolExecutor) selectBestIP(ips []*iplibrary.DomainIPRecord) *iplibrary.DomainIPRecord {
    // 选择策略：
    // 1. 健康状态
    // 2. 成功率
    // 3. 延迟
    // 4. 使用频率
    
    best := ips[0]
    for _, ip := range ips[1:] {
        if ip.SuccessRate > best.SuccessRate {
            best = ip
        } else if ip.SuccessRate == best.SuccessRate {
            if ip.Latency < best.Latency {
                best = ip
            }
        }
    }
    
    return best
}

// getProtocolOrder 获取协议尝试顺序
func (e *MultiProtocolExecutor) getProtocolOrder(startProtocol string) []string {
    order := make([]string, 0)
    found := false
    
    for _, proto := range e.config.ProtocolPriority {
        if proto == startProtocol {
            found = true
        }
        if found {
            order = append(order, proto)
        }
    }
    
    return order
}
```

### 3. 协议检测器

```go
package protocol

import (
    "context"
    "crypto/tls"
    "net"
    "time"
)

// ProtocolDetector 协议检测器
type ProtocolDetector struct {
    logger *logs.Logger
}

// DetectSupportedProtocols 检测支持的协议
func (d *ProtocolDetector) DetectSupportedProtocols(
    ctx context.Context,
    target *Target,
) ([]string, error) {
    protocols := make([]string, 0)
    
    // 1. 检测HTTP/3（QUIC）
    if d.detectHTTP3(ctx, target) {
        protocols = append(protocols, "http3")
    }
    
    // 2. 检测HTTP/2
    if d.detectHTTP2(ctx, target) {
        protocols = append(protocols, "http2")
    }
    
    // 3. HTTP/1.1总是支持
    protocols = append(protocols, "http1.1")
    
    return protocols, nil
}

// detectHTTP3 检测HTTP/3支持
func (d *ProtocolDetector) detectHTTP3(ctx context.Context, target *Target) bool {
    // 尝试建立QUIC连接
    // 如果成功，说明支持HTTP/3
    // 实现QUIC连接检测逻辑
    return false
}

// detectHTTP2 检测HTTP/2支持
func (d *ProtocolDetector) detectHTTP2(ctx context.Context, target *Target) bool {
    // 通过TLS ALPN检测
    conn, err := tls.DialWithDialer(
        &net.Dialer{Timeout: 5 * time.Second},
        "tcp",
        net.JoinHostPort(target.Value, "443"),
        &tls.Config{
            NextProtos: []string{"h2", "http/1.1"},
        },
    )
    if err != nil {
        return false
    }
    defer conn.Close()
    
    // 检查ALPN协商结果
    state := conn.ConnectionState()
    for _, proto := range state.NegotiatedProtocol {
        if proto == "h2" {
            return true
        }
    }
    
    return false
}
```

## 优化建议

### 1. IP库优化

1. **分层缓存**：
   - L1缓存：内存缓存（热数据）
   - L2缓存：持久化存储（冷数据）
   - L3缓存：DNS解析（实时数据）

2. **智能更新**：
   - 基于TTL自动更新
   - 失败触发更新
   - 使用频率触发更新

3. **IP健康管理**：
   - 定期健康检查
   - 失败自动标记
   - 成功率统计

### 2. 协议选择优化

1. **自适应选择**：
   - 根据网络环境选择
   - 根据目标服务器选择
   - 根据历史性能选择

2. **协议检测缓存**：
   - 缓存协议检测结果
   - 定期刷新检测结果

3. **降级策略**：
   - 智能降级（根据错误类型）
   - 快速降级（超时快速切换）

### 3. 连接池优化

1. **协议分离**：
   - 不同协议使用独立连接池
   - 避免协议混用

2. **连接复用**：
   - HTTP/2和HTTP/3充分利用多路复用
   - HTTP/1.1使用Keep-Alive

3. **健康检查**：
   - 定期检查连接健康
   - 自动清理无效连接

## 配置示例

```go
// 系统配置
config := &SystemConfig{
    // IP库配置
    IPLibrary: &IPLibraryConfig{
        UpdateInterval:       1 * time.Hour,
        IPExpiration:         24 * time.Hour,
        HealthCheckInterval:  5 * time.Minute,
        MaxIPsPerDomain:      10,
        MinHealthyIPs:        3,
    },
    
    // 协议配置
    Protocol: &ProtocolConfig{
        Priority: []string{"http3", "http2", "http1.1"},
        Fallback: &FallbackStrategy{
            OnFailure: true,
            OnTimeout: true,
            FallbackOrder: []string{"http3", "http2", "http1.1"},
        },
    },
    
    // 路由配置
    Routing: &RoutingConfig{
        Strategy: StrategyIPFirst,
        Fallback: StrategyDomainFirst,
    },
    
    // 连接池配置
    ConnectionPool: &ConnectionPoolConfig{
        HTTP11: &TCPPoolConfig{
            MaxConnections: 100,
            MaxIdleConnections: 20,
        },
        HTTP2: &HTTP2PoolConfig{
            MaxConnections: 50,
            MaxIdleConnections: 10,
        },
        HTTP3: &QUICPoolConfig{
            MaxConnections: 50,
            MaxIdleConnections: 10,
        },
    },
}
```

