# 多协议爬虫系统 - 最佳实践建议

## 1. IP库管理最佳实践

### 1.1 IP库更新策略

**推荐策略：混合更新**

```go
// 混合更新策略
type HybridUpdateStrategy struct {
    // 定时全量更新（每天一次）
    FullUpdateInterval time.Duration // 24小时
    
    // 增量更新（每小时一次）
    IncrementalUpdateInterval time.Duration // 1小时
    
    // 按需更新（实时）
    OnDemandUpdate bool
}
```

**实施建议**：
- **启动时**：加载持久化的IP库
- **运行中**：
  - 定时全量更新：每天凌晨执行一次
  - 增量更新：每小时更新活跃域名
  - 按需更新：请求时如果IP库中没有，立即解析并缓存
- **失败时**：IP失败后立即触发更新

### 1.2 IP选择策略

**推荐策略：加权选择**

```go
// 权重配置
weights := &SelectionWeights{
    SuccessRate: 0.4,  // 成功率权重最高
    Latency:     0.3,  // 延迟权重
    Health:      0.2,  // 健康状态权重
    UseCount:    0.1,  // 使用次数权重（使用越少越好）
}
```

**实施建议**：
- **新IP**：给予较高权重，优先尝试
- **健康IP**：优先选择成功率高、延迟低的IP
- **失败IP**：降低权重，但不要立即移除（可能是临时故障）

### 1.3 IP健康检查

**推荐策略：分层检查**

```go
// 分层健康检查
type LayeredHealthCheck struct {
    // L1: 快速检查（TCP连接）
    QuickCheckInterval time.Duration // 1分钟
    
    // L2: 标准检查（HTTP HEAD）
    StandardCheckInterval time.Duration // 5分钟
    
    // L3: 深度检查（HTTP GET）
    DeepCheckInterval time.Duration // 30分钟
}
```

**实施建议**：
- **快速检查**：TCP连接测试，快速发现不可用IP
- **标准检查**：HTTP HEAD请求，检查服务可用性
- **深度检查**：完整HTTP请求，检查功能完整性

## 2. 协议选择最佳实践

### 2.1 协议优先级配置

**推荐配置**：

```go
// 根据场景配置协议优先级
var ProtocolPriorities = map[string][]string{
    // 高延迟网络（移动网络）
    "high_latency": []string{"http3", "http2", "http1.1"},
    
    // 低延迟网络（本地网络）
    "low_latency": []string{"http2", "http3", "http1.1"},
    
    // 高并发场景
    "high_concurrency": []string{"http2", "http3", "http1.1"},
    
    // 通用场景
    "general": []string{"http3", "http2", "http1.1"},
}
```

**实施建议**：
- **默认**：HTTP/3优先（性能最好）
- **降级**：HTTP/3失败 → HTTP/2 → HTTP/1.1
- **检测**：首次请求时检测支持的协议，缓存结果

### 2.2 协议降级策略

**推荐策略：智能降级**

```go
// 智能降级策略
type SmartFallbackStrategy struct {
    // 可降级的错误类型
    RetryableErrors []string // ["connection_error", "timeout"]
    
    // 不可降级的错误类型
    NonRetryableErrors []string // ["auth_error", "not_found"]
    
    // 降级延迟
    FallbackDelay time.Duration // 100ms
}
```

**实施建议**：
- **连接错误**：立即降级
- **超时错误**：等待后降级
- **认证错误**：不降级，直接返回错误
- **404错误**：不降级，直接返回错误

## 3. 路由策略最佳实践

### 3.1 IP优先策略

**推荐策略：智能IP优先**

```go
// 智能IP优先策略
type SmartIPFirstStrategy struct {
    // IP可用性阈值
    IPAvailabilityThreshold float64 // 0.8
    
    // 最小健康IP数量
    MinHealthyIPs int // 3
    
    // 降级条件
    FallbackConditions []FallbackCondition
}
```

**实施建议**：
- **IP可用性高**：优先使用IP
- **IP可用性低**：降级到域名
- **IP数量不足**：降级到域名

### 3.2 域名降级策略

**推荐策略：渐进式降级**

```go
// 渐进式降级
1. IP直接连接（最快）
   ↓ 失败
2. IP + SNI（支持虚拟主机）
   ↓ 失败
3. 域名连接（最兼容）
```

**实施建议**：
- **首次尝试**：IP直接连接
- **SNI支持**：如果目标支持虚拟主机，使用IP+SNI
- **最终降级**：使用域名连接

## 4. 连接池管理最佳实践

### 4.1 连接池大小配置

**推荐配置**：

```go
// 连接池大小配置
type ConnectionPoolSizes struct {
    // HTTP/1.1: 每个域名独立连接池
    HTTP11PerDomain int // 10-20
    
    // HTTP/2: 单连接多路复用
    HTTP2PerDomain int // 1-3
    
    // HTTP/3: 单连接多路复用
    HTTP3PerDomain int // 1-3
}
```

**实施建议**：
- **HTTP/1.1**：每个域名10-20个连接
- **HTTP/2**：每个域名1-3个连接（多路复用）
- **HTTP/3**：每个域名1-3个连接（多路复用）

### 4.2 连接复用策略

**推荐策略：协议分离 + 域名分离**

```go
// 连接池结构
type ConnectionPoolStructure struct {
    // 协议分离
    Pools map[string]*DomainPool // "http1.1", "http2", "http3"
    
    // 域名分离
    DomainPools map[string]*ProtocolPool // 每个域名独立池
}
```

**实施建议**：
- **协议分离**：不同协议使用独立连接池
- **域名分离**：每个域名使用独立连接池
- **IP分离**：每个IP使用独立连接池（可选）

## 5. 性能优化最佳实践

### 5.1 DNS解析优化

**推荐策略：多级缓存**

```go
// 多级DNS缓存
type MultiLevelDNSCache struct {
    // L1: 内存缓存（热数据）
    MemoryCache *sync.Map
    
    // L2: 持久化缓存（冷数据）
    PersistentCache *FileCache
    
    // L3: DNS服务器（实时数据）
    DNSServers []string
}
```

**实施建议**：
- **内存缓存**：TTL 5分钟
- **持久化缓存**：TTL 1小时
- **DNS服务器**：多个DNS服务器轮询

### 5.2 IP库持久化

**推荐策略：增量持久化**

```go
// 增量持久化
type IncrementalPersistence struct {
    // 持久化间隔
    Interval time.Duration // 5分钟
    
    // 变更触发
    ChangeTrigger bool
    
    // 压缩存储
    Compress bool
}
```

**实施建议**：
- **定时持久化**：每5分钟持久化一次
- **变更触发**：IP状态变化时立即持久化
- **压缩存储**：使用压缩格式减少存储空间

## 6. 错误处理最佳实践

### 6.1 错误分类

**推荐分类**：

```go
// 错误类型
type ErrorType string

const (
    // 可重试错误
    ErrorConnection ErrorType = "connection"  // 连接错误
    ErrorTimeout    ErrorType = "timeout"     // 超时错误
    ErrorDNS        ErrorType = "dns"         // DNS错误
    
    // 不可重试错误
    ErrorAuth       ErrorType = "auth"        // 认证错误
    ErrorNotFound   ErrorType = "not_found"   // 404错误
    ErrorServer     ErrorType = "server"      // 5xx错误
)
```

**实施建议**：
- **可重试**：连接错误、超时错误、DNS错误
- **不可重试**：认证错误、404错误
- **条件重试**：5xx错误（可重试，但需要限制次数）

### 6.2 重试策略

**推荐策略：指数退避**

```go
// 指数退避重试
type ExponentialBackoffRetry struct {
    MaxRetries   int           // 3
    InitialDelay time.Duration // 100ms
    MaxDelay     time.Duration // 5s
    Multiplier   float64       // 2.0
}
```

**实施建议**：
- **首次重试**：100ms后
- **第二次重试**：200ms后
- **第三次重试**：400ms后
- **最大延迟**：5秒

## 7. 监控和统计最佳实践

### 7.1 关键指标

**推荐指标**：

```go
// 关键指标
type KeyMetrics struct {
    // 请求指标
    TotalRequests      int64
    SuccessfulRequests int64
    FailedRequests     int64
    AverageLatency     time.Duration
    
    // 协议指标
    ProtocolStats map[string]*ProtocolStats
    
    // IP指标
    IPStats map[string]*IPStats
    
    // 连接池指标
    ConnectionPoolStats map[string]*PoolStats
}
```

**实施建议**：
- **实时监控**：请求成功率、平均延迟
- **协议统计**：各协议的使用率和成功率
- **IP统计**：IP使用率和健康状态
- **连接池统计**：连接池使用率和效率

### 7.2 告警策略

**推荐告警**：

```go
// 告警配置
type AlertConfig struct {
    // 成功率告警
    SuccessRateThreshold float64 // 0.95
    
    // 延迟告警
    LatencyThreshold time.Duration // 2s
    
    // IP健康告警
    IPHealthThreshold float64 // 0.8
}
```

**实施建议**：
- **成功率低于95%**：发送告警
- **平均延迟超过2秒**：发送告警
- **IP健康率低于80%**：发送告警

## 8. 安全最佳实践

### 8.1 指纹轮换

**推荐策略：智能轮换**

```go
// 智能指纹轮换
type SmartFingerprintRotation struct {
    // 轮换频率
    RotationInterval time.Duration // 10分钟
    
    // 轮换策略
    Strategy RotationStrategy // "random", "round_robin"
    
    // 会话一致性
    SessionConsistency bool
}
```

**实施建议**：
- **每次请求**：随机选择指纹
- **同一会话**：保持指纹一致性
- **定期更新**：定期更新指纹库

### 8.2 IP分散

**推荐策略：均匀分散**

```go
// IP分散策略
type IPDistributionStrategy struct {
    // 分散算法
    Algorithm DistributionAlgorithm // "round_robin", "weighted"
    
    // 分散范围
    DistributionRange int // 所有可用IP
    
    // 使用频率限制
    RateLimit int // 每个IP每分钟最多使用10次
}
```

**实施建议**：
- **均匀使用**：所有IP均匀使用
- **频率限制**：每个IP使用频率限制
- **健康优先**：优先使用健康IP

## 9. 配置管理最佳实践

### 9.1 配置分层

**推荐分层**：

```go
// 配置分层
type ConfigLayers struct {
    // 默认配置
    Default *CrawlerConfig
    
    // 环境配置
    Environment map[string]*CrawlerConfig
    
    // 域名特定配置
    DomainSpecific map[string]*CrawlerConfig
    
    // 运行时配置
    Runtime *CrawlerConfig
}
```

**实施建议**：
- **默认配置**：通用默认值
- **环境配置**：不同环境不同配置
- **域名配置**：特定域名特殊配置
- **运行时配置**：动态调整配置

### 9.2 配置热更新

**推荐策略：热更新**

```go
// 配置热更新
type HotReloadConfig struct {
    // 配置文件路径
    ConfigPath string
    
    // 监听间隔
    WatchInterval time.Duration
    
    // 更新回调
    OnUpdate func(*CrawlerConfig)
}
```

**实施建议**：
- **文件监听**：监听配置文件变化
- **热更新**：配置变化时自动更新
- **平滑切换**：新配置生效时平滑切换

## 10. 总结

### 核心原则

1. **IP优先，域名降级**：优先使用IP，失败后降级到域名
2. **协议自适应**：根据网络环境自动选择最佳协议
3. **智能降级**：根据错误类型智能降级
4. **连接复用**：充分利用连接池和协议多路复用
5. **健康管理**：持续监控和维护IP和连接健康状态
6. **性能优化**：多级缓存、增量更新、异步处理
7. **错误处理**：分类处理、智能重试、快速恢复
8. **监控告警**：实时监控、及时告警、快速响应

### 实施优先级

1. **第一阶段**：基础功能
   - IP库管理
   - 多协议支持
   - 基本降级

2. **第二阶段**：性能优化
   - 连接池优化
   - 缓存优化
   - 并发优化

3. **第三阶段**：智能优化
   - 自适应选择
   - 智能降级
   - 健康管理

4. **第四阶段**：监控运维
   - 监控告警
   - 统计分析
   - 配置管理

