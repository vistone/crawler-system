# 爬虫反审查系统 - 集成示例代码

## 完整集成示例

### 1. 系统初始化

```go
package main

import (
    "context"
    "fmt"
    "time"

    "github.com/vistone/fingerprint"
    "github.com/vistone/logs"
    "github.com/vistone/quic"
    "github.com/vistone/conn"
    "github.com/vistone/netconnpool"
    "github.com/vistone/domaindns"
    "github.com/vistone/localippool"
)

// CrawlerSystem 爬虫系统核心结构
type CrawlerSystem struct {
    logger          *logs.Logger
    ipPool          *localippool.Pool
    dnsResolver     *domaindns.Resolver
    fingerprintMgr  *FingerprintManager
    tcpConnPool     *netconnpool.Pool
    quicConnPool    *quic.Pool
}

// NewCrawlerSystem 创建新的爬虫系统
func NewCrawlerSystem() (*CrawlerSystem, error) {
    // 1. 初始化日志系统
    logger := logs.NewLogger(logs.InfoLevel)
    logger.Info("初始化爬虫系统...")

    // 2. 初始化IP池
    ipPool := localippool.NewPool()
    // 添加IP地址（示例）
    ipPool.AddIP("192.168.1.100")
    ipPool.AddIP("192.168.1.101")
    ipPool.AddIP("192.168.1.102")
    logger.Info("IP池初始化完成", "ip_count", ipPool.Count())

    // 3. 初始化DNS解析器
    dnsResolver := domaindns.NewResolver()
    dnsResolver.SetDNSServers([]string{
        "8.8.8.8",
        "8.8.4.4",
        "1.1.1.1",
        "1.0.0.1",
    })
    logger.Info("DNS解析器初始化完成")

    // 4. 初始化指纹管理器
    fingerprintMgr := NewFingerprintManager(logger)

    // 5. 初始化TCP连接池
    tcpConnPool, err := netconnpool.NewPool(
        netconnpool.WithMaxConnections(100),
        netconnpool.WithMaxIdleConnections(20),
        netconnpool.WithIdleTimeout(30*time.Second),
        netconnpool.WithDNSResolver(dnsResolver),
        netconnpool.WithIPPool(ipPool),
        netconnpool.WithFingerprintManager(fingerprintMgr),
        netconnpool.WithLogger(logger),
    )
    if err != nil {
        return nil, fmt.Errorf("创建TCP连接池失败: %w", err)
    }
    logger.Info("TCP连接池初始化完成")

    // 6. 初始化QUIC连接池
    quicConnPool, err := quic.NewPool(
        quic.WithMaxConnections(50),
        quic.WithMaxIdleConnections(10),
        quic.WithIdleTimeout(30*time.Second),
        quic.WithDNSResolver(dnsResolver),
        quic.WithIPPool(ipPool),
        quic.WithFingerprintManager(fingerprintMgr),
        quic.WithLogger(logger),
    )
    if err != nil {
        return nil, fmt.Errorf("创建QUIC连接池失败: %w", err)
    }
    logger.Info("QUIC连接池初始化完成")

    return &CrawlerSystem{
        logger:         logger,
        ipPool:         ipPool,
        dnsResolver:    dnsResolver,
        fingerprintMgr: fingerprintMgr,
        tcpConnPool:    tcpConnPool,
        quicConnPool:   quicConnPool,
    }, nil
}

// FingerprintManager 指纹管理器
type FingerprintManager struct {
    logger *logs.Logger
}

func NewFingerprintManager(logger *logs.Logger) *FingerprintManager {
    return &FingerprintManager{
        logger: logger,
    }
}

// GetRandomFingerprint 获取随机指纹
func (fm *FingerprintManager) GetRandomFingerprint() (*fingerprint.FingerprintResult, error) {
    result, err := fingerprint.GetRandomFingerprint()
    if err != nil {
        fm.logger.Error("获取随机指纹失败", "error", err)
        return nil, err
    }
    fm.logger.Debug("获取随机指纹", "name", result.Name)
    return result, nil
}

// GetFingerprintByBrowser 根据浏览器类型获取指纹
func (fm *FingerprintManager) GetFingerprintByBrowser(browserType string) (*fingerprint.FingerprintResult, error) {
    result, err := fingerprint.GetRandomFingerprintByBrowser(browserType)
    if err != nil {
        fm.logger.Error("获取指纹失败", "browser", browserType, "error", err)
        return nil, err
    }
    fm.logger.Debug("获取指纹", "browser", browserType, "name", result.Name)
    return result, nil
}
```

### 2. 请求执行器

```go
// RequestExecutor 请求执行器
type RequestExecutor struct {
    system *CrawlerSystem
}

// NewRequestExecutor 创建请求执行器
func NewRequestExecutor(system *CrawlerSystem) *RequestExecutor {
    return &RequestExecutor{
        system: system,
    }
}

// RequestOptions 请求选项
type RequestOptions struct {
    URL            string
    Method         string
    Headers        map[string]string
    Body           []byte
    UseQUIC        bool
    BrowserType    string
    Timeout        time.Duration
    RetryCount     int
    RetryDelay     time.Duration
}

// Execute 执行HTTP请求
func (re *RequestExecutor) Execute(ctx context.Context, opts RequestOptions) (*Response, error) {
    logger := re.system.logger

    // 1. 获取随机指纹
    fp, err := re.system.fingerprintMgr.GetRandomFingerprint()
    if err != nil {
        return nil, fmt.Errorf("获取指纹失败: %w", err)
    }

    // 合并请求头
    headers := fp.Headers.ToMap()
    for k, v := range opts.Headers {
        headers[k] = v
    }

    // 2. 解析域名
    domain := extractDomain(opts.URL)
    targetIP, err := re.system.dnsResolver.Resolve(ctx, domain)
    if err != nil {
        logger.Error("DNS解析失败", "domain", domain, "error", err)
        return nil, fmt.Errorf("DNS解析失败: %w", err)
    }
    logger.Debug("DNS解析成功", "domain", domain, "ip", targetIP)

    // 3. 获取可用IP
    localIP, err := re.system.ipPool.GetAvailableIP()
    if err != nil {
        logger.Error("获取IP失败", "error", err)
        return nil, fmt.Errorf("获取IP失败: %w", err)
    }
    logger.Debug("获取本地IP", "ip", localIP)

    // 4. 获取连接
    var connection conn.Connection
    if opts.UseQUIC {
        connection, err = re.system.quicConnPool.GetConnection(ctx, &netconnpool.ConnectionOptions{
            TargetIP:  targetIP,
            LocalIP:   localIP,
            Fingerprint: fp.Profile,
            Headers:   headers,
        })
    } else {
        connection, err = re.system.tcpConnPool.GetConnection(ctx, &netconnpool.ConnectionOptions{
            TargetIP:  targetIP,
            LocalIP:   localIP,
            Fingerprint: fp.Profile,
            Headers:   headers,
        })
    }
    if err != nil {
        logger.Error("获取连接失败", "error", err)
        return nil, fmt.Errorf("获取连接失败: %w", err)
    }
    defer connection.Close()

    // 5. 发送请求
    response, err := re.sendRequest(ctx, connection, opts, headers)
    if err != nil {
        // 标记IP为可疑
        re.system.ipPool.MarkSuspicious(localIP)
        return nil, fmt.Errorf("发送请求失败: %w", err)
    }

    // 6. 标记IP为正常
    re.system.ipPool.MarkHealthy(localIP)

    return response, nil
}

// sendRequest 发送HTTP请求
func (re *RequestExecutor) sendRequest(
    ctx context.Context,
    conn conn.Connection,
    opts RequestOptions,
    headers map[string]string,
) (*Response, error) {
    logger := re.system.logger

    // 构建HTTP请求
    req := &HTTPRequest{
        Method:  opts.Method,
        URL:     opts.URL,
        Headers: headers,
        Body:    opts.Body,
    }

    logger.Info("发送请求", "method", opts.Method, "url", opts.URL)

    // 发送请求
    resp, err := conn.SendRequest(ctx, req)
    if err != nil {
        logger.Error("请求失败", "error", err)
        return nil, err
    }

    logger.Info("请求成功", "status", resp.StatusCode, "url", opts.URL)

    return resp, nil
}

// Response HTTP响应
type Response struct {
    StatusCode int
    Headers    map[string]string
    Body       []byte
}

// HTTPRequest HTTP请求
type HTTPRequest struct {
    Method  string
    URL     string
    Headers map[string]string
    Body    []byte
}

// extractDomain 从URL提取域名
func extractDomain(url string) string {
    // 简化的域名提取逻辑
    // 实际实现需要更完善的URL解析
    return url
}
```

### 3. 连接池集成示例

```go
// TCP连接池配置示例
func setupTCPConnPool(
    logger *logs.Logger,
    dnsResolver *domaindns.Resolver,
    ipPool *localippool.Pool,
    fingerprintMgr *FingerprintManager,
) (*netconnpool.Pool, error) {
    pool, err := netconnpool.NewPool(
        // 连接池大小
        netconnpool.WithMaxConnections(100),
        netconnpool.WithMaxIdleConnections(20),
        
        // 超时设置
        netconnpool.WithConnectTimeout(10*time.Second),
        netconnpool.WithIdleTimeout(30*time.Second),
        netconnpool.WithReadTimeout(30*time.Second),
        netconnpool.WithWriteTimeout(30*time.Second),
        
        // 依赖注入
        netconnpool.WithDNSResolver(dnsResolver),
        netconnpool.WithIPPool(ipPool),
        netconnpool.WithFingerprintManager(fingerprintMgr),
        netconnpool.WithLogger(logger),
        
        // 连接健康检查
        netconnpool.WithHealthCheckInterval(60*time.Second),
        netconnpool.WithHealthCheckFunc(func(conn conn.Connection) bool {
            // 自定义健康检查逻辑
            return conn.IsHealthy()
        }),
    )
    return pool, err
}

// QUIC连接池配置示例
func setupQUICConnPool(
    logger *logs.Logger,
    dnsResolver *domaindns.Resolver,
    ipPool *localippool.Pool,
    fingerprintMgr *FingerprintManager,
) (*quic.Pool, error) {
    pool, err := quic.NewPool(
        // 连接池大小
        quic.WithMaxConnections(50),
        quic.WithMaxIdleConnections(10),
        
        // 超时设置
        quic.WithConnectTimeout(10*time.Second),
        quic.WithIdleTimeout(30*time.Second),
        
        // 依赖注入
        quic.WithDNSResolver(dnsResolver),
        quic.WithIPPool(ipPool),
        quic.WithFingerprintManager(fingerprintMgr),
        quic.WithLogger(logger),
        
        // QUIC特定配置
        quic.WithMaxStreams(100),
        quic.WithKeepAliveInterval(30*time.Second),
    )
    return pool, err
}
```

### 4. IP池管理示例

```go
// IP池管理示例
func setupIPPool(logger *logs.Logger) *localippool.Pool {
    pool := localippool.NewPool()

    // 添加IP地址
    ips := []string{
        "192.168.1.100",
        "192.168.1.101",
        "192.168.1.102",
        "10.0.0.1",
        "10.0.0.2",
    }

    for _, ip := range ips {
        pool.AddIP(ip)
        logger.Info("添加IP", "ip", ip)
    }

    // 设置IP健康检查
    pool.SetHealthCheckFunc(func(ip string) bool {
        // 自定义健康检查逻辑
        // 例如：ping测试、连接测试等
        return true
    })

    // 设置IP使用频率限制
    pool.SetRateLimit(10, time.Minute) // 每分钟最多使用10次

    return pool
}
```

### 5. DNS解析器配置示例

```go
// DNS解析器配置示例
func setupDNSResolver(logger *logs.Logger) *domaindns.Resolver {
    resolver := domaindns.NewResolver()

    // 设置DNS服务器
    resolver.SetDNSServers([]string{
        "8.8.8.8",      // Google DNS
        "8.8.4.4",      // Google DNS
        "1.1.1.1",      // Cloudflare DNS
        "1.0.0.1",      // Cloudflare DNS
        "223.5.5.5",    // 阿里DNS
        "114.114.114.114", // 114 DNS
    })

    // 启用DNS缓存
    resolver.EnableCache(true)
    resolver.SetCacheTTL(5 * time.Minute)

    // 设置解析超时
    resolver.SetTimeout(5 * time.Second)

    // 设置重试次数
    resolver.SetRetryCount(3)

    logger.Info("DNS解析器配置完成")
    return resolver
}
```

### 6. 完整使用示例

```go
func main() {
    // 1. 初始化系统
    system, err := NewCrawlerSystem()
    if err != nil {
        panic(fmt.Sprintf("系统初始化失败: %v", err))
    }
    defer system.Close()

    // 2. 创建请求执行器
    executor := NewRequestExecutor(system)

    // 3. 执行请求
    ctx := context.Background()
    response, err := executor.Execute(ctx, RequestOptions{
        URL:         "https://example.com/api/data",
        Method:      "GET",
        UseQUIC:     false,
        BrowserType: "chrome",
        Timeout:     30 * time.Second,
        RetryCount:  3,
        RetryDelay:  1 * time.Second,
    })
    if err != nil {
        system.logger.Error("请求执行失败", "error", err)
        return
    }

    // 4. 处理响应
    system.logger.Info("请求成功", 
        "status", response.StatusCode,
        "body_length", len(response.Body),
    )

    // 处理响应数据...
    fmt.Printf("响应状态码: %d\n", response.StatusCode)
    fmt.Printf("响应体长度: %d\n", len(response.Body))
}

// Close 关闭系统资源
func (cs *CrawlerSystem) Close() error {
    cs.logger.Info("关闭爬虫系统...")
    
    if cs.tcpConnPool != nil {
        cs.tcpConnPool.Close()
    }
    
    if cs.quicConnPool != nil {
        cs.quicConnPool.Close()
    }
    
    cs.logger.Info("系统关闭完成")
    return nil
}
```

## 错误处理示例

```go
// 带重试的请求执行
func (re *RequestExecutor) ExecuteWithRetry(
    ctx context.Context,
    opts RequestOptions,
) (*Response, error) {
    var lastErr error
    
    for i := 0; i < opts.RetryCount; i++ {
        if i > 0 {
            time.Sleep(opts.RetryDelay)
            re.system.logger.Info("重试请求", "attempt", i+1, "url", opts.URL)
        }

        response, err := re.Execute(ctx, opts)
        if err == nil {
            return response, nil
        }

        lastErr = err
        re.system.logger.Warn("请求失败", 
            "attempt", i+1,
            "error", err,
            "url", opts.URL,
        )

        // 根据错误类型决定是否继续重试
        if !isRetryableError(err) {
            break
        }
    }

    return nil, fmt.Errorf("请求失败，已重试%d次: %w", opts.RetryCount, lastErr)
}

// isRetryableError 判断错误是否可重试
func isRetryableError(err error) bool {
    // 网络错误、超时错误等可以重试
    // 认证错误、404错误等不应该重试
    return true // 简化示例
}
```

